from pymongo import MongoClient
import pymongo
import bcrypt
from bson import Binary, ObjectId
from django.http import HttpRequest
from datetime import datetime, timezone, timedelta
from datetime import datetime, timezone
import bson

# Create a new connection to the polylink database
con = MongoClient("mongodb://localhost:27017")
db = con["polylink"]

# Let's define some utilities functions
def register(firstname, lastname, username, password, profile_bytes, profile_format):
    """ This handles a new user registration. It returns nothing"""
    db.users.insert_one({
        "first_name": firstname,
        "last_name": lastname,
        "username": username,
        "password": bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt()).decode("utf-8"),
        "avatar": Binary(profile_bytes),
        "avatar_format": profile_format,
    })
    return

def login(username, password):
    """ Handles user login. It creates a new session and returns its id if successful or returns None otherwise."""
    user = db.users.find_one({"username": username})
    if user: 
        if bcrypt.checkpw(password.encode("utf-8"), user["password"].encode("utf-8")):  # check if password matches
            # Create a new session
            session = db.sessions.insert_one({})  # generate it first to have a _id generated by MongoDB
            session_id = str(session.inserted_id)
            db.sessions.update_one(             # take that _id, stringuy it and use it as a session_id
                {"_id": session.inserted_id},
                {"$set": {
                    "session_id": session_id,
                    "user_id": user["_id"],
                    }
                },
            )

            return session_id
    return None

def change_password(username, old_password, new_password):
    """ Handles password changes for users. Returns true if succesful, fasle otherwise."""
    user = db.users.find_one({"username": username})
    if user: 
        if bcrypt.checkpw(old_password.encode("utf-8"), user["password"].encode("utf-8")):  # check if password matches
            db.users.update_one(
                {"username": user["username"]}, 
                {
                    "$set": {"password": bcrypt.hashpw(new_password.encode("utf-8"), bcrypt.gensalt()).decode("utf-8")}
                }
            )
            return True
    return False

def get_user_by_session_id(session_id):
    """ This retrieve a user from the database using a session id. I returns a dictionny containing information about the user."""
    session = db.sessions.find_one({"session_id": session_id})
    if session:
        user_id = session["user_id"]
        user = db.users.find_one({"_id": user_id})
        return user 
    return None

def get_user(request: HttpRequest):
    """ This retrieve a user from the database using a session id. The retrieve the session id from the receive request object.
        It returns a dictionny containing information about the user. """
    session_id = request.COOKIES.get("session_id", None)
    if not session_id:
        return None
    return get_user_by_session_id(session_id)

def get_user_id_by_session_id(session_id):
    """ This retrieves a user'id from the database using a session id. It returns the id in a string representation """
    user_id = db.sessions.find_one({"session_id": session_id})["user_id"]
    if not user_id:
        return None
    return user_id

def get_user_id(request: HttpRequest):
    """ This retrieve a user from the database using a session id. The retrieve the session id from the receive request object.
    It returns a dictionny containing information about the user. """
    return get_user_id_by_session_id(request.COOKIES.get("session_id", None))


def remove_session(session_id):
    """ Handles sessions deletion. It returns true if succesful"""
    session = db.sessions.delete_one({"session_id": session_id})
    return bool(session)
    
def isUsername(username):
    return bool(db.users.find_one({"username": username}))

##### utily function for testing purpose only
def output_dict(dic):
    print("{")
    for key, value in dic.items():
        print(f"{key}: {value}")
    print("}")

# polylink/db.py

def create_notification(recipient_id, actor_id, post_id, action_type, content=None):
    """Crée une notification pour un utilisateur"""
    actor = db.users.find_one({"_id": actor_id})
    if not actor:
        return False
    
    # Vérifier si une notification similaire existe déjà dans les dernières minutes
    existing_notification = db.notifications.find_one({
        "recipient_id": recipient_id,
        "actor_id": actor_id,
        "post_id": post_id,
        "action_type": action_type,
        "timestamp": {
            "$gte": datetime.now(timezone.utc) - timedelta(minutes=5)
        }
    })
    
    if existing_notification:
        return True  # Éviter les doublons de notifications
    
    # Récupérer le contenu du post pour les likes
    post_content = None
    if action_type == "like":
        post = db.posts.find_one({"_id": ObjectId(post_id)})
        if post:
            post_content = post.get("content", "")[:100]  # Limiter à 100 caractères
    
    notification_data = {
        "recipient_id": recipient_id,
        "actor_id": actor_id,
        "actor_username": actor["username"],
        "post_id": post_id,
        "action_type": action_type,
        "timestamp": datetime.now(timezone.utc),
        "read": False
    }
    
    # Ajouter le contenu approprié selon le type d'action
    if action_type == "comment" and content:
        notification_data["content"] = content
    elif action_type == "like" and post_content:
        notification_data["content"] = post_content
    
    db.notifications.insert_one(notification_data)
    return True

def get_user_notifications(user_id, page=1, per_page=10):
    """Récupère les notifications d'un utilisateur avec pagination"""
    skip = (page - 1) * per_page
    
    # Compter le nombre total de notifications non lues
    unread_count = db.notifications.count_documents({
        "recipient_id": user_id,
        "read": False
    })
    
    # Récupérer les notifications paginées
    notifications = list(db.notifications.find({"recipient_id": user_id})
        .sort("timestamp", pymongo.DESCENDING)
        .skip(skip)
        .limit(per_page))
    
    # Conversion des ObjectId en strings
    for notif in notifications:
        notif["id"] = str(notif["_id"])
        notif["post_id"] = str(notif["post_id"])
        notif["actor_id"] = str(notif["actor_id"])
    
    return {
        "notifications": notifications,
        "unread_count": unread_count,
        "has_more": len(notifications) == per_page
    }

def mark_notification_as_read(notification_id):
    """Marque une notification comme lue"""
    result = db.notifications.update_one(
        {"_id": ObjectId(notification_id)},
        {"$set": {"read": True}}
    )
    return result.modified_count > 0

def mark_all_notifications_as_read(user_id):
    """Marque toutes les notifications d'un utilisateur comme lues"""
    result = db.notifications.update_many(
        {
            "recipient_id": user_id,
            "read": False
        },
        {"$set": {"read": True}}
    )
    return result.modified_count

def get_notification_preview(notification_id):
    """Récupère un aperçu de la notification avec les détails du post associé"""
    notification = db.notifications.find_one({"_id": ObjectId(notification_id)})
    if not notification:
        return None
        
    post = db.posts.find_one({"_id": ObjectId(notification["post_id"])})
    if not post:
        return None
        
    return {
        "notification": {
            "id": str(notification["_id"]),
            "actor_username": notification["actor_username"],
            "action_type": notification["action_type"],
            "timestamp": notification["timestamp"],
            "read": notification["read"]
        },
        "post": {
            "id": str(post["_id"]),
            "content": post.get("content", ""),
            "image": bool(post.get("image", False))
        }
    }
def update_user(user_id, update_data):
    """ Updates user information in the database. """
    # Ensure user_id is ObjectId
    if not isinstance(user_id, bson.ObjectId):
         try:
             user_id = bson.ObjectId(user_id)
         except bson.errors.InvalidId:
             return False # Invalid ID format
             
    # Remove potentially problematic fields from update_data
    update_data.pop('_id', None)
    update_data.pop('id', None)
    update_data.pop('username', None)
    update_data.pop('password', None)
    update_data.pop('avatar', None)
    update_data.pop('avatar_format', None)

    # Ajoutez ici la gestion des champs phone_number, bio et location
    # Assurez-vous que ces champs sont présents dans update_data avant de les utiliser
    # update_data['phone_number'] = update_data.get('phone_number', None)
    # update_data['bio'] = update_data.get('bio', None)
    # update_data['location'] = update_data.get('location', None)

    if not update_data: # No valid fields to update
        return False

    result = db.users.update_one(
        {"_id": user_id},
        {"$set": update_data}
    )
    return result.modified_count > 0


